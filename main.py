# -*- coding: utf-8 -*-
import re
import os
import glob
import string
import argparse
import hashlib
import multiprocessing

import xlrd
import xlwt

import docxparser
from match import match

def create_folder(path):
    if not os.path.exists(path):
        os.makedirs(path)
        print('create folder:', path)

def format_log(s, blank=2):
    """
    align '\t' of multiple rows
    blank: minimum space between two columns
    example:
      format_log('a\nb\tccc\td\neee\tf\tg') =
      '
        a
        b    ccc  d
        eee  f    g
      '
    """
    L = s.split('\n')
    while True:
        m = -1
        for s in L:
            if '\t' in s:
                m = max(m, s.index('\t'))
        if m == -1:
            return '\n'.join(L)
        else:
            for i in range(len(L)):
                s = L[i]
                if '\t' in s:
                    x = s.index('\t')
                    L[i] = s[:x]+' '*(blank+m-x)+s[x+1:]


def scoring(user_file: str, answer: str):
    """
    user_file:    user's docx filepath
    answer:       text of answer.docx
    return:       Dict:{'score':float,'log':str}
    """
    file = os.path.basename(user_file)
    suffix = file.split('.')[-1]
    try:
        user_input = docxparser.process(user_file)
    except:
        log = 'Parse docx error. Your file: '+file
        score = 0.0
        return {'score': score, 'log': log}

    # find all task
    task_pattern = r'\$(.*?)\|(.*?)\|(.*?)\$'
    split_pattern = r'\$.*?\|.*?\|.*?\$'
    # List[Tuple[task_id,answer,score]]
    tasks = re.findall(task_pattern, answer)
    tasks = [(str(task_id), str(answer), float(score))
             for task_id, answer, score in tasks]
    # parse user's answer
    template_str = ''
    task_address = []
    for s in re.split(split_pattern, answer):
        template_str += s
        task_address.append(len(template_str))
    pair = match(user_input, template_str)
    addr_mapping = dict()
    for now_addr in range(len(pair)):
        a, b = pair[now_addr]
        if b:
            addr_mapping[len(addr_mapping)] = now_addr
    addr_mapping[len(addr_mapping)] = len(pair)
    user_answer = []
    for i in task_address:
        L = pair[addr_mapping[i-1]+1:addr_mapping[i]]
        user_answer.append((''.join(a for a, b in L)).strip())
    user_answer = user_answer[:len(tasks)]

    # now user_answer[i]:str <-> tasks[i]:Tuple[task_id,answerStr,score]
    sum_score = 0.0
    log = 'This report is generated by the automatic marking program\n'
    for uanswer, (task_id, answer, score) in zip(user_answer, tasks):
        if uanswer.lower() == answer.lower():
            sum_score += float(score)
            result_symbol = '√'+f'  +{score}'
        else:
            result_symbol = '×'
        #log += f'  Task:{task_id}\tAnswer:"{answer}"\tYour_Answer:"{uanswer}"\t{result_symbol}\n'
        log += f'  Task:{task_id}\tYour_Answer:"{uanswer}"\t{result_symbol}\n'
    log += f'Total Score: {sum_score}\n'
    log = format_log(log)
    print(file, sum_score)
    return {'score': sum_score, 'log': log}


if __name__ == "__main__":
    # parse args
    parser = argparse.ArgumentParser()
    parser.add_argument('-a', '--answer', type=str,
                        required=True, help='file path of answer.docx')
    parser.add_argument('-d', '--data', type=str,
                        required=True, help='folder path of student.docx')
    parser.add_argument('-e', '--excel', type=str,
                        required=True, help='file path of template.xls')
    parser.add_argument('-r', '--result', type=str,
                        required=True, help='folder path of result')
    parser.add_argument('-s', '--server', type=str,
                        required=True, help='the server address that displays the log')
    args = parser.parse_args()
    # pre-work
    answer = docxparser.process(args.answer)
    data_path = os.path.abspath(args.data)
    user_files = glob.glob(os.path.join(data_path, '*.*'))
    workbook = xlrd.open_workbook(args.excel)
    assert(len(workbook.sheets()) == 1)
    print('answer.docx:', repr(answer[:100]) +
          ('' if len(answer) < 100 else '......'))
    print('Find', len(user_files), 'files in student folder.')
    D = dict()
    for s in user_files:
        suffix = s.split('.')[-1]
        D[suffix] = D.get(suffix, 0)+1
    D = sorted([(k, v) for k, v in D.items()], key=lambda x: -x[1])
    print('\n'.join([f'\t.{k}:{v}' for k, v in D]))
    studentID = [os.path.basename(s).split('_')[0] for s in user_files]
    for i in range(len(studentID)):
        if len(studentID[i]) != 10 or any(c not in string.digits for c in studentID[i]):
            print('Illegal file:', os.path.basename(user_files[i]))
    result_path = os.path.abspath(args.result)
    log_path =  os.path.join(result_path,'log')
    create_folder(result_path)
    create_folder(log_path)
    begin = input('Press Y to be continue: ')
    if begin.lower() == 'y':
        with multiprocessing.Pool(16) as p:
            result = p.starmap(scoring, [(user_files[i], answer)
                                         for i in range(len(user_files))])
        # write result
        rsheet = workbook.sheet_by_index(0)
        wbk = xlwt.Workbook()
        wsheet = wbk.add_sheet(rsheet.name, cell_overwrite_ok=True)
        for i in range(rsheet.nrows):
            for j in range(rsheet.ncols):
                wsheet.write(i, j, rsheet.cell(i, j).value)
        for i in range(rsheet.nrows):
            id = rsheet.cell(i, 1).value
            if id in studentID:
                D = result[studentID.index(id)]
                wsheet.write(i, 4, D['score'])
                if len(D['log'])<500:
                    wsheet.write(i, 5, D['log'])
                else:
                    # Since the log is usually very large, the log will be written to the file
                    m=hashlib.md5()
                    m.update(str.encode(D['log']))
                    log_name = m.hexdigest()
                    with open(os.path.join(log_path,log_name),'wb') as w:
                        w.write(str.encode(D['log'],encoding='utf-8'))
                    wsheet.write(i, 5, 'The scoring details are here: '+args.server+log_name)
        wbk.save(os.path.join(result_path, 'result.xls'))
